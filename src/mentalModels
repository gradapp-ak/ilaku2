Arrays:
=========

Sliding window
    dynamic
        The window moves forward until the condition is not met. once the condition is met, the tail
        window pointer shrinks the window until the condition is not met again
    fixed
        The window size is fixed and just moved one element at a time to find the condition met
    jump ahead
    constraint based


Kadane's algorithm:
    Start a sequence, at each position an element joins the current sequence or starts it's own sequence.
    Typically the ask is to find the max subarray. In a twist to this pattern it may be worthwhile
    to keep both running max and running min and find solutions from them

Array Storage pattern:
    Use the array itself as storage. For example, when an array is given with the numbers within
    <=0<a[i]<=n, where n=a.length. then if count is needed the elements at an index can be added
    with n+1. element=n+1+element, So this way element can be obtained by element%(n+1) and number
    of elements at index can be obtained by elements/n+1
Rotated Array:
    Divide and conquer. Find the pivot first and then apply the needful. Like finding the minimum
    or finding an element

2 pointers in an array
    The array could be sorted or not given the problem.
    Start at start and end. Depending on if that setup is over or under the target, one side of the
    array is shrunk.

DP:

Array/String iterate from the end instead of beginning

String matching algorithm ->
    palindrome checks. Start at each string and expand out either side and keep checking for palindrome
    Another good technique is to start with each character as 1 length palindrome. Next base case is to
    add all 2 letter palindromes in the string.
    After that use these base cases as foundation and expand on either side. check if it's a
    palindrome and store it in an array. Then use this as a base and check for even bigger length
    so on and so forth.
    This algorithm can be used to match longest string match between 2 strings

//DataStructures
Stack
Array

Tree
    Heap (min-heap/max heap)
    n-ary tree (can have more than 2 child)
    Binary tree
    Binary search tree
    Balanced tree (Have to check) (AVL,Redblack)
    Complete Binary tree (uniformly filled left to right)
    + Full binary tree (All the nodes have 0 or 2 children) = Perfect binary trees
    Tries (Prefix tree)

    Binary search tree traversal
    DFS
        recursive, recursive with 2 trees simultaneously, iterative DFS especially inorder using a stack
    BFS

Graphs
    DFS
     BFS
    Bidirectional Search
    Topological Sort
    Dijikstra's shortest path algorithm
    Union Find
    Prim's algorithm - min/max spanning tree

//Algorithm techniques
  2 pointers
    leading and lagging pointers
        lagging pointers dynamic/resetting or fixed follower
    left and right pointers
    fast and slow pointers

  Scan twice
    Scan the array/linkedList twice. First time to infer meta data like
     length of an linkedlist and use that to solve the problem
     LinkedList delete problems can be tracked using fakeHead and/or tail

  Sliding windows
  String searches (Longest common substring)


//problematic
Modified binary search: like rotated array and few more
bit manipulation
String matching (Longest palindrome etc)
LinkedList Sort
Construct binary tree from it's inorder and preorder traversals.
3Sum
 Sort first and do brute force
union find -> number of islands
wiggle sort
 Master theorem -> time complexity of a recursive algorithm
 2D Arrays have been a problem, especially rotation
 Pow of operator in logrithmic time-> but why

