sliding window
    dynamic
    fixed
    jump ahead
    constraint based

2 pointers in an array
Array/String iterate from the end instead of beginning
String matching algorithm ->
    palindrome checks. Start at each string and expand out either side and keep checking for palindrome
    Another good technique is to start with each character as 1 length palindrome. Next base case is to
    add all 2 letter palindromes in the string.
    After that use these base cases as foundation and expand on either side. check if it's a
    palindrome and store it in an array. Then use this as a base and check for even bigger length
    so on and so forth.
    This algorithm can be used to match longest string match between 2 strings

//DataStructures
Stack
Array

Tree
    Heap (min-heap/max heap)
    n-ary tree (can have more than 2 child)
    Binary tree
    Binary search tree
    Balanced tree (Have to check) (AVL,Redblack)
    Complete Binary tree (uniformly filled left to right)
    + Full binary tree (All the nodes have 0 or 2 children) = Perfect binary trees
    Tries (Prefix tree)

    Binary search tree traversal
    DFS
        recursive, recursive with 2 trees simultaneously, iterative DFS especially inorder using a stack
    BFS

Graphs
    DFS
     BFS
    Bidirectional Search
    Topological Sort
    Dijikstra's shortest path algorithm
    Union Find
    Prim's algorithm - min/max spanning tree

//Algorithm techniques
  2 pointers
    leading and lagging pointers
        lagging pointers dynamic/resetting or fixed follower
    left and right pointers
    fast and slow pointers

  Scan twice
    Scan the array/linkedList twice. First time to infer meta data like
     length of an linkedlist and use that to solve the problem
     LinkedList delete problems can be tracked using fakeHead and/or tail

  Sliding windows
  String searches (Longest common substring)


//problematic
Modified binary search: like rotated array and few more
bit manipulation
String matching (Longest palindrome etc)
LinkedList Sort
Construct binary tree from it's inorder and preorder traversals.
3Sum
 Sort first and do brute force
union find -> number of islands
wiggle sort
 Master theorem -> time complexity of a recursive algorithm
 2D Arrays have been a problem, especially rotation
 Pow of operator in logrithmic time-> but why

